#!./luajit
--------------------------------------------------------------------------------
--  This file is part of NetCamel
--  Copyright (C) 2014 Lee Essen <lee.essen@nowonline.co.uk>
--
--  This program is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------

require("log")
--local runtime = require("runtime")
local service = require("service")

local DNSMASQ = "/usr/sbin/dnsmasq"
local DNSMASQ_CONF = "/tmp/dnsmasq.conf"

--
-- Start DNSMASQ using the service framework
--
local function start_dnsmasq()
	service.define("dnsmasq", {
		["binary"] = DNSMASQ,
		["args"] = { "--conf-file=" .. DNSMASQ_CONF },
		["name"] = "dnsmasq",
		["pidfile"] = "/var/run/dnsmasq.pid",
		["maxkilltime"] = 1000,
		["start"] = "NORMALLY",
		["stop"] = "BYPIDFILE" })

	log("info", "starting dnsmasq")
	
	local rc, err = service.start("dnsmasq")
	print("dnsmasq.start rc="..tostring(rc).." err="..tostring(err))
	return true
end
local function stop_dnsmasq()
	log("info", "stopping dnsmasq")
	local rc, err = service.stop("dnsmasq")
	print("dnsmasq.start rc="..tostring(rc).." err="..tostring(err))
	service.remove("dnsmasq")
end

--
-- Create the DNSMASQ config file based on our config, we'll create a
-- list with the output so we can use it in different ways for precommit
-- and commit
--
local function build_config()
	local conf = {}

	--
	-- First process the forwarding section
	--
	if node_exists("/service/dns/forwarding", CF_new) then
		local forwarding = node_vars("/service/dns/forwarding", CF_new)
		push(conf, "# -- forwarding --")
		push(conf, string.format("cache-size=%s", forwarding["cache-size"]))
		for interface in each(forwarding["listen-on"] or {}) do
			push(conf, string.format("interface=%s", interface_name(interface)))
		end
		if forwarding.server then
			--
			-- Manual server entries
			--
			for server in each(forwarding.servers) do
				push(conf, string.format("server=%s", server))
			end
		else
			--
			-- Autogenerated resolv.conf
			--
			push(conf, string.format("resolv-file=%s", "/tmp/resolv.conf.auto"))
		end
		for option in each(forwarding.options or {}) do
			push(conf, string.format("options=%s", option))
		end
		push(conf, "")
	end

	--
	-- DHCP Ranges
	--
	if node_exists("/service/dhcp/range", CF_new) then
		push(conf, "# -- dhcp ranges --")
		for rangename in each(node_list("/service/dhcp/range", CF_new)) do
			print("RANGENAME="..rangename)
			local cf = node_vars("/service/dhcp/range/"..rangename, CF_new)
			local rc = "dhcp-range="..cf.start
			if(cf["end"]) then rc = rc .. "," .. cf["end"] end
			if(cf.netmask) then rc = rc .. "," .. cf.netmask end
			if(cf.broadcast) then rc = rc .. "," .. cf.broadcast end
			if(cf.leasetime) then rc = rc .. "," .. cf.leasetime end
			push(conf, rc)
		end
		push(conf, "")
	end

	--
	-- Domain-Match
	--
	if node_exists("/service/dns/domain-match", CF_new) then
		push(conf, "# -- domain-match --")
		for v in each(node_list("/service/dns/domain-match", CF_new)) do
			local dmatch = node_vars("/service/dns/domain-match/"..v, CF_new)
			if dmatch.group then
				push(conf, "# ("..v:sub(2)..")")
				for domain in each(dmatch.domain) do
					push(conf, string.format("ipset=/%s/"..dmatch.group, domain))
				end
			end
		end
		push(conf, "")
	end

	return conf
end


--
-- DNSMASQ is fairly simple since we don't really process any changes,
-- we will completely re-write the config any time there is a change
-- and restart (or start or stop) the daemon as needed.
--
local function dnsmasq_commit(changes)
	print("Hello From DNSMASQ")
	logroot("dnsmasq")

	--
	-- If we were running then we need to stop
	--
	if node_exists("/service/dns", CF_current) or node_exists("/service/dhcp/range", CF_current) then
		stop_dnsmasq()
	end

	--
	-- Check to see if we have a config at all!
	--
	if not node_exists("/service/dns", CF_new) and not node_exists("/service/dhcp", CF_new) then
		print("No DNSMASQ config required, stopping daemon")
		return true
	end

	--
	-- Create the config file
	--
	local fd = io.open(DNSMASQ_CONF, "w+")
	if not fd then
		log("error", "unable to create %s", DNSMASQ_CONF)
		return false
	end
	local cf = build_config()
	for line in each(cf) do fd:write(line.."\n") end
	fd:close()

	start_dnsmasq()
	return true
end

--
-- The precommit function must ensure that anything we reference
-- exists in the new config so that we know we will reference valid
-- items and hence ensure the commit is as likely as possible to 
-- succeed in one go.
-- 
-- For dnsmasq this means checking any referenced interfaces and
-- ipsets
--
local function dnsmasq_precommit(changes)
	logroot("dnsmasq")
	--
	-- dns/forwarding has a 'listen-on' interface list
	--
	if CF_new["/service/dns/forwarding/listen-on"] then
		for interface in each(CF_new["/service/dns/forwarding/listen-on"]) do
			if not node_exists(interface_path(interface), CF_new) then
				return false, string.format("/service/dns/forwarding/listen-on interface not valid: %s", interface)
			end
		end
	end
	--
	-- dns/domain-match has an ipset reference
	--
	if node_exists("/service/dns/domain-match", CF_new) then
		print("DOMAINMATCH")
		for node in each(matching_list("/service/dns/domain-match/%/group", CF_new)) do
			local set = CF_new[node]
			if not node_exists("/iptables/set/*"..set, CF_new) then
				return false, string.format("%s ipset not valid: %s", node, set)
			end
		end
	end
	--
	-- dhcp ranges need a start point, and if they have a broadcast they must
	-- have a netmask
	--
	if node_exists("/service/dhcp/range", CF_new) then
		for node in each(node_list("/service/dhcp/range", CF_new)) do
			local cf = node_vars("/service/dhcp/range/"..node, CF_new)
			local rangename = node:gsub("^*", "")
			if not cf.start then return false, "/service/dhcp/range/"..rangename.." requires start address" end
			if cf.broadcast and not cf.netmask then
				return false, "/service/dhcp/range/"..rangename.." broadcast requires netmask entry"
			end
		end
	end

	--
	-- Now build the config file and run it through a test
	--
	local conf, err = build_config()
	if not conf then return false, err end

	local rc, out = pipe_execute(DNSMASQ, { "--test", "--conf-file=-" }, conf, nil )
	if rc ~= 0 then
		local err = out[2] or "unknown error"
		local e, line = err:match("^(.*) at line (%d+) of")

		print("err="..tostring(err))
		print("out2="..tostring(out[2]))
		print("rc="..rc.." line="..tostring(line).." e="..tostring(e))

		if e then return false, e..": "..conf[tonumber(line)] end
		return false, "dnsmasq config error: "..err
	end

	return true
end


VALIDATOR["text_label"] = function(v, mp, kp)
	return OK
end

VALIDATOR["ipset"] = function(v, mp, kp)
	return OK
end

--
-- Main interface config definition
--
master["/service/dns"] = 						{ ["commit"] = dnsmasq_commit,
												  ["precommit"] = dnsmasq_precommit }

master["/service/dns/forwarding"] = {}
master["/service/dns/forwarding/cache-size"] = 	{ ["type"] = "OK", ["default"] = 200 }
master["/service/dns/forwarding/listen-on"] = 	{ ["type"] = "any_interface", 
												  ["options"] = "all_interfaces",
												  ["list"] = 1 }
master["/service/dns/forwarding/server"] = 		{ ["type"] = "OK", ["list"] = 1 }
master["/service/dns/forwarding/options"] = 		{ ["type"] = "OK", ["list"] = 1 }

master["/service/dns/domain-match"] = {}
master["/service/dns/domain-match/*"] = 			{ ["style"] = "text_label" }
master["/service/dns/domain-match/*/domain"] = 	{ ["type"] = "OK", ["list"] = 1 }
master["/service/dns/domain-match/*/group"] = 	{ ["type"] = "ipset" }

master["/service/dns/file"] = 					{ ["type"] = "file/text" }

master["/service/dhcp"] = 						{  ["delegate"] = "/service/dns" }
master["/service/dhcp/range"] =					{}
master["/service/dhcp/range/*"] =				{ ["style"] = "OK" }
master["/service/dhcp/range/*/start"] = 			{ ["type"] = "ipv4" }
master["/service/dhcp/range/*/end"] = 			{ ["type"] = "ipv4" }
master["/service/dhcp/range/*/broadcast"] = 		{ ["type"] = "ipv4" }
master["/service/dhcp/range/*/netmask"] = 		{ ["type"] = "ipv4" }
master["/service/dhcp/range/*/leasetime"] =		{ ["type"] = "OK" }


