#!./luajit
--------------------------------------------------------------------------------
--  This file is part of NetCamel
--  Copyright (C) 2014 Lee Essen <lee.essen@nowonline.co.uk>
--
--  This program is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------

require("log")
--local runtime = require("runtime")
local service = require("service")

local DNSMASQ = "/usr/sbin/dnsmasq"
local DNSMASQ_CONF = "/tmp/dnsmasq.conf"

--
-- Start DNSMASQ using the service framework
--
local function start_dnsmasq()
	service.define("dnsmasq", {
		["binary"] = DNSMASQ,
		["args"] = { "--conf-file=" .. DNSMASQ_CONF },
		["name"] = "dnsmasq",
		["pidfile"] = "/var/run/dnsmasq.pid",
		["maxkilltime"] = 1000,
		["start"] = "NORMALLY",
		["stop"] = "BYPIDFILE" })

	log("info", "starting dnsmasq")
	
	local rc, err = service.start("dnsmasq")
	print("dnsmasq.start rc="..tostring(rc).." err="..tostring(err))
	return true
end
local function stop_dnsmasq()
	log("info", "stopping dnsmasq")
	local rc, err = service.stop("dnsmasq")
	print("dnsmasq.start rc="..tostring(rc).." err="..tostring(err))
	service.remove("dnsmasq")
end

--
-- DNSMASQ is fairly simple since we don't really process any changes,
-- we will completely re-write the config any time there is a change
-- and restart (or start or stop) the daemon as needed.
--
local function dnsmasq_commit(changes)
	print("Hello From DNSMASQ")
	logroot("dnsmasq")

	--
	-- If we were running then we need to stop
	--
	if node_exists("dns", CF_current) or node_exists("dhcp", CF_current) then
		stop_dnsmasq()
	end

	--
	-- Check to see if we have a config at all!
	--
	if not node_exists("dns", CF_new) and not node_exists("dhcp", CF_new) then
		print("No DNSMASQ config required, stopping daemon")
		return true
	end

	--
	-- Create the config file
	--
	local fd = io.open(DNSMASQ_CONF, "w+")
	if not fd then
		log("error", "unable to create %s", DNSMASQ_CONF)
		return false
	end
		
	--
	-- First process the forwarding section
	--
	if node_exists("dns/forwarding", CF_new) then
		local forwarding = node_vars("dns/forwarding", CF_new)
		fd:write("# -- forwarding --\n\n")
		fd:write(string.format("cache-size=%s\n", forwarding["cache-size"]))
		for interface in each(forwarding["listen-on"] or {}) do
			fd:write(string.format("interface=%s\n", interface_name(interface)))
		end
		if forwarding.server then
			--
			-- Manual server entries
			--
			for server in each(forwarding.servers) do
				fd:write(string.format("server=%s\n", server))
			end
		else
			--
			-- Autogenerated resolv.conf
			--
			fd:write(string.format("resolv-file=%s\n", "/tmp/resolv.conf.auto"))
		end
		for option in each(forwarding.options or {}) do
			fd:write(string.format("options=%s\n", option))
		end
		fd:write("\n")
	end

	--
	-- Domain-Match
	--
	if node_exists("dns/domain-match", CF_new) then
		fd:write("# -- domain-match --\n\n")
		for v in each(node_list("dns/domain-match", CF_new)) do
			local dmatch = node_vars("dns/domain-match/"..v, CF_new)
			if dmatch.group then
				fd:write("# ("..v:sub(2)..")\n")
				for domain in each(dmatch.domain) do
					fd:write(string.format("ipset=/%s/"..dmatch.group.."\n", domain))
				end
			end
		end
		fd:write("\n")
	end
	fd:close()

	start_dnsmasq()
	return true
end

--
-- The precommit function must ensure that anything we reference
-- exists in the new config so that we know we will reference valid
-- items and hence ensure the commit is as likely as possible to 
-- succeed in one go.
-- 
-- For dnsmasq this means checking any referenced interfaces and
-- ipsets
--
local function dnsmasq_precommit(changes)
	--
	-- dns/forwarding has a 'listen-on' interface list
	--
	if CF_new["dns/forwarding/listen-on"] then
		for interface in each(CF_new["dns/forwarding/listen-on"]) do
			if not node_exists(interface_path(interface), CF_new) then
				return false, string.format("dns/forwarding/listen-on interface not valid: %s", interface)
			end
		end
	end
	--
	-- dns/domain-match has an ipset reference
	--
	if node_exists("dns/domain-match", CF_new) then
		print("DOMAINMATCH")
		for node in each(matching_list("dns/domain-match/%/group", CF_new)) do
			local set = CF_new[node]
			if not node_exists("iptables/set/*"..set, CF_new) then
				return false, string.format("%s ipset not valid: %s", node, set)
			end
		end
	end
	return true
end


VALIDATOR["text_label"] = function(v, kp)
	return OK
end

VALIDATOR["ipset"] = function(v, kp)
	return OK
end

--
-- Main interface config definition
--
master["dns"] = { ["commit"] = dnsmasq_commit,
				  ["precommit"] = dnsmasq_precommit }

master["dns/forwarding"] = {}
master["dns/forwarding/cache-size"] = 	{ ["type"] = "OK", ["default"] = 200 }
master["dns/forwarding/listen-on"] = 	{ ["type"] = "any_interface", 
										  ["options"] = "all_interfaces",
										  ["list"] = 1 }
master["dns/forwarding/server"] = 		{ ["type"] = "OK", ["list"] = 1 }
master["dns/forwarding/options"] = 		{ ["type"] = "OK", ["list"] = 1 }

master["dns/domain-match"] = {}
master["dns/domain-match/*"] = 			{ ["style"] = "text_label" }
master["dns/domain-match/*/domain"] = 	{ ["type"] = "OK", ["list"] = 1 }
master["dns/domain-match/*/group"] = 	{ ["type"] = "ipset" }


master["dns/file"] = 					{ ["type"] = "file/text" }

master["dhcp"] = 						{  ["delegate"] = "dns" }
master["dhcp/flag"] = 					{ ["type"] = "string" }


