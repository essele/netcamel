#!./luajit
--------------------------------------------------------------------------------
--  This file is part of NetCamel
--  Copyright (C) 2014 Lee Essen <lee.essen@nowonline.co.uk>
--
--  This program is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------

--local service = require("service")

local NTPD = "/usr/sbin/ntpd"
local NTPD_NAME = "ntpd"
local NTPD_CONFIG = "/tmp/ntpd.conf"
local NTPD_ARGS = { "-c", NTPD_CONFIG, "-g" }

--
-- NTP has a number of configuration options which we need to worry about,
-- also, if we are running the server as a server we need to trigger the
-- (input-standard-services) iptable macro
--
local function ntp_commit(changes)
	print("Hello From NTP")

	local cf = node_vars_if_exists("/service/ntp", CF_new) or {}

	--
	-- Stop the daemon...
	--
	lib.service.stop("ntpd")

	--
	-- Check to see if we have a config at all!
	--
	if not next(cf) then
		print("No NTP config required, stopping daemon")
		return true
	end

	--
	-- Create the configfile dictionary, map listen-on to interface names
	--
	local cfdict = { 
		["server"] = cf.server, 	
		["interface"] = interface_names(cf["listen-on"])
	}

	--
	-- Build the configuration file...
	--
	local cfdata = [[
		#
		# <autogenerated ntp.conf file -- do not edit>
		#
		server {{server}} iburst

		restrict default kod nomodify notrap nopeer noquery
		restrict -6 default kod nomodify notrap nopeer noquery

		restrict 127.0.0.1
		restrict -6 ::1

		#
		# We will listen on all interfaces by default
		# since it makes it easier to control where the
		# packets with be received from.
		#
		# The iptables rules will limit the service if
		# listen-on interfaces are not configured.
		#
		# interface ignore wildcard
		# interface listen 127.0.0.1
		#
		# interface listen {{interface}}
		#
	]]
	create_config_file(NTPD_CONFIG, cfdata, cfdict)

	--
	-- If we are not enabled then exit before we start..
	--
	if not cf.enable then return true end

	--
	-- Start the daemon...
	--
	lib.service.start("ntpd")

	return true
end

--
-- Precommit will check to make sure the configuration makes sense, this
-- basically means that, if we are enabled, then we must have some servers
-- configured.
--
-- If we are providing a service then we must listen on one or more valid
-- interfaces.
--
local function ntp_precommit(changes)
	local cf = node_vars_if_exists("/service/ntp", CF_new) or {}

	--
	-- if we are not enabled then we don't really care about anything
	--
	if not cf.enable then return true end

	--
	-- make sure we have at least one server configured
	--
	if #(cf.server or {}) < 1 then
		return false, "/service/ntp/server must have at least one server configured"
	end

	--
	-- if we are not providing a service, then we are done, otherwise
	-- check the interfaces are ok
	--
	if not cf["provide-service"] then return true end
	if #(cf["listen-on"] or {}) < 1 then
		return false, "/service/ntp/listen-on must list at least one interface for provide-service"
	end
	for interface in each(cf["listen-on"]) do
--		if not node_exists(interface_path(interface), CF_new) then
		if not is_valid_interface(interface) then
			return false, string.format("/service/ntp/listen-on interface not valid: %s", interface)
		end
	end
	return true
end

--
-- Provide the iptables rules for the iptables module, this assumes we
-- are using the CF_new configuration and just opens up ports using the
-- (input-allowed-services)
--
local function ntp_iptables_rules()
	local rules = {}

	print("AT NTP_IPTABLES_RULES")

	print("eable="..tostring(CF_new["/service/ntp/enable"]))
	print("prov-svc="..tostring(CF_new["/service/ntp/provide-service"]))

	if CF_new["/service/ntp/enable"] == true and CF_new["/service/ntp/provide-service"] == true then
		print("We are enabled")
		for interface in each(CF_new["/service/ntp/listen-on"] or {}) do
			print("Interface is: "..interface)
			interface = interface_name(interface)
			table.insert(rules, string.format("-i %s -p udp --dport 123 -j ACCEPT", interface))
		end
	end
	print("DONE RETURNING RULES")
	return rules
end


--
-- Main interface config definition
--
master["/service"] = {}
master["/service/ntp"] = { 
	["commit"] = ntp_commit,
	["precommit"] = ntp_precommit 
}

master["/service/ntp/enable"] = { ["type"] = "boolean" }
master["/service/ntp/provide-service"] = { ["type"] = "boolean" }
master["/service/ntp/listen-on"] = { ["type"] = "any_interface", 
									["options"] = "all_interfaces",
									["list"] = 1 }
master["/service/ntp/server"] = { ["type"] = "OK", ["list"] = 1 }


function ntp_init()
	print("INIT_NTP")
	--
	-- Define the service so that we can stop, start and monitor the
	-- daemon.
	--
	lib.service.define("ntpd", {
		["binary"] = NTPD,
		["args"] = NTPD_ARGS,
		["name"] = NTPD_NAME,

		["start"] = "NORMALLY",
		["stop"] = "BYNAME",
	})

	--
	-- If we change the settings we will need to adjust the iptables
	-- macro
	--
	add_trigger("/service/ntp/enable", "/iptables/*MACROS/@(input-allowed-services)")
	add_trigger("/service/ntp/provide-service", "/iptables/*MACROS/@(input-allowed-services)")
	add_trigger("/service/ntp/listen-on", "/iptables/*MACROS/@(input-allowed-services)")

	--
	-- Make sure we can contribute to the allowed services list...
	--
	iptables_add_macro_item("(input-allowed-services)", ntp_iptables_rules)
end

